# From polling to pushing

Objective:
As mentioned before, kpack will by default, poll the source code repo for commits every 5 minutes, and automatically re-build the image if it detects a new commit.

This means kpack is not a sequential part of the build pipeline like Kaniko or the Tekton Buildpack Task.
This is fine, as long as you always wish to build an image regardless of linting and testing feedback.

In this step, you will:
- Make kpack builds conditional on linting and testing feedback, using a push instead of a poll model

We can trigger kpack at the end of the build pipeline by updating the `Image` resource.
The kpack controller tracks all `Image` resources in the cluster.
If the Git revision of an `Image` were to change, the controller will automatically kick off a build and push.

## Change the Git revision in a new Task

Create the `Task` responsible for updating the `Image` file with the new revision.
This `Task` is very similar to the one we created for promoting newly pushed images to the dev environment in the triggers [triggers](https://www.katacoda.com/springone-tour-2020-cicd/scenarios/5-manage-triggers) scenarios.

```
cat <<EOF >update-image-revision-task.yaml
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: update-image-revision
spec:
  workspaces:
    - name: source
  params:
    - name: GITHUB_TOKEN_SECRET
      type: string
      description: Name of the secret holding the github-token.
      default: github-token
    - name: GITHUB_TOKEN_SECRET_KEY
      type: string
      description: Name of the secret key holding the github-token.
      default: GITHUB_TOKEN
    - name: REVISION
      type: string
      description: The source code repository's Git revision to build with kpack.
EOF
```{{execute}}

You can now add two steps.
The first step modifies the `Image` with the new revision.

```
cat <<EOF >>update-image-revision-task.yaml
  steps:
  - name: update-revision
    image: mikefarah/yq
    workingDir: \$(workspaces.source.path)
    script: |
        cd kpack
        yq w -i image.yaml "spec.source.git.revision" "\$(GIT_COMMIT)"
EOF
```{{execute}}

And the second step commits the changes.

```
cat <<EOF >>update-image-revision-task.yaml
  - name: git-commit
    image: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.12.1
    workingDir: \$(workspaces.source.path)
    script: |
      git remote set-url origin https://${GITHUB_USER}:\${GITHUB_TOKEN}@github.com/${GITHUB_NS}/go-sample-app-ops.git
      git config user.name build-bot
      git config user.email build-bot@bots.bot
      git checkout -b temp-branch
      git add kpack/image.yaml
      git commit -m "Setting revision to current source code repo commit to trigger kpack"
      git checkout master
      git merge temp-branch
      git push origin master
    env:
      - name: GITHUB_TOKEN
        valueFrom:
          secretKeyRef:
            name: \$(params.GITHUB_TOKEN_SECRET)
            key: \$(params.GITHUB_TOKEN_SECRET_KEY)
EOF
```{{execute}}

Take a look at the entire `Task`, and apply it to the cluster.

```
yq r -C update-image-revision-task.yaml
kubectl apply -f update-image-revision-task.yaml
```{{execute}}

## Update the build pipeline

We can now use this newly created `Task` to trigger kpack.

First of all we need to remove the two existing image related tasks from the build pipeline.

```
cd ../tekton
yq d -i build-pipeline.yaml "spec.tasks.(name==verify-digest)"
yq d -i build-pipeline.yaml "spec.tasks.(name==build-image)"
```{{execute}}

Next, you'll need to reference the new `Task`.

```
yq m -i -a build-pipeline.yaml - <<EOF
spec:
  tasks:
    - name: update-image-revision
      taskRef:
        name: update-image-revision
      runAfter:
        - fetch-repository
        - lint
        - test
      workspaces:
        - name: source
          workspace: shared-workspace
      params:
        - name: GITHUB_TOKEN_SECRET
          value: \$(params.github-token-secret)
        - name: GITHUB_TOKEN_SECRET_KEY
          value: \$(params.github-token-secret-key)
        - name: REVISION
          value: \$(params.branch-name)
EOF
```{{execute}}

Don't forget to add the new parameters to the pipeline.

```
yq m -i -a build-pipeline.yaml - <<EOF
spec:
  params:
    - name: github-token-secret
      type: string
      description: Name of the secret holding the github-token.
    - name: github-token-secret-key
      description: Name of the secret key holding the github-token.
EOF
```{{execute}}

And you can also remove the image parameter, as that will be generated by kpack.

```
yq d -i build-pipeline.yaml "spec.params.(name==image)"
```{{execute}}

Take a look at the entire `Pipeline`, and apply it to the cluster.

```
yq r -C build-pipeline.yaml
kubectl apply -f build-pipeline.yaml
```{{execute}}

## Turn off polling

You can now turn off the automatic polling, by changing the `updatePolicy` to `external`.

```
cd ../kpack
yq m -i builder.yaml - <<EOF
spec:
  updatePolicy: external
EOF
```{{execute}}

Go ahead and apply the `Builder` to the cluster as well.

```
kubectl apply -f builder.yaml
```{{execute}}

## Using Argo CD to trigger kpack

If you would now trigger the build pipeline, the `Image` file will be modified with a new revision in Git.
For now, you'd have to apply the new `Image` modification to the cluster manually, or have another `Task` in the pipeline that does this.

We can however use Argo CD for this as well.
Argo CD should pick up the changed manifest and apply it to the cluster automatically.

Let's move to step 6 to put the entire flow together.
